
========================================
PATH: /Users/sarthak/Projects/filepecker/README.md
---
## ‚öôÔ∏è Advanced Usage

You can customize the behavior using flags:

| Flag | Description | Example |
| :--- | :--- | :--- |
| `-o` | Set the output filename (default: file.txt) | `filepecker -o mycode.txt` |
| `-ignore` | Comma-separated list of extensions to skip | `filepecker -ignore .json,.css` |

**Example:**
Scan the directory, but output to `backup.txt` and ignore all markdown and JSON files:

```bash
filepecker -o backup.txt -ignore .md,.json

========================================
PATH: /Users/sarthak/Projects/filepecker/go.mod
---
module github.com/Sarthak160/file-pecker

go 1.24.3


========================================
PATH: /Users/sarthak/Projects/filepecker/install.sh
---
#!/bin/bash

# ==========================================================
# CONFIGURATION
# ==========================================================
REPO_OWNER="Sarthak160"  
REPO_NAME="filepecker"    
BIN_NAME="filepecker"
INSTALL_DIR="/usr/local/bin"
# ==========================================================

set -e # Exit immediately if a command exits with a non-zero status

# 1. Detect OS & Arch
OS="$(uname -s)"
ARCH="$(uname -m)"
EXT=""

case "${OS}" in
    Linux*)     OS='linux';;
    Darwin*)    OS='darwin';;
    CYGWIN*|MINGW*|MSYS*) OS='windows'; EXT='.exe';;
    *)          echo "Error: Unsupported OS: ${OS}"; exit 1;;
esac

case "${ARCH}" in
    x86_64)    ARCH='amd64';;
    arm64|aarch64) ARCH='arm64';;
    *)         echo "Error: Unsupported Architecture: ${ARCH}"; exit 1;;
esac

TARGET_BINARY="${BIN_NAME}-${OS}-${ARCH}${EXT}"
DOWNLOAD_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/latest/download/${TARGET_BINARY}"

# 2. Download
echo "‚¨áÔ∏è  Downloading ${BIN_NAME} for ${OS}/${ARCH}..."
tmp_dir=$(mktemp -d)
curl -fsSL "$DOWNLOAD_URL" -o "${tmp_dir}/${BIN_NAME}"

# 3. Make Executable
chmod +x "${tmp_dir}/${BIN_NAME}"

# 4. Install
echo "üì¶ Installing to ${INSTALL_DIR}..."

# Check if we have write access to INSTALL_DIR, otherwise use sudo
if [ -w "$INSTALL_DIR" ]; then
    mv "${tmp_dir}/${BIN_NAME}" "${INSTALL_DIR}/${BIN_NAME}"
else
    sudo mv "${tmp_dir}/${BIN_NAME}" "${INSTALL_DIR}/${BIN_NAME}"
fi

# 5. Cleanup
rm -rf "$tmp_dir"

echo "‚úÖ Success! Run '${BIN_NAME}' to get started."

========================================
PATH: /Users/sarthak/Projects/filepecker/main.go
---
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// 1. Define Command Line Flags
	outputPtr := flag.String("o", "file.txt", "Output filename")
	ignorePtr := flag.String("ignore", "", "Comma-separated extensions to ignore (e.g. .json,.md)")
	flag.Parse()

	outputFilename := *outputPtr
	ignoreList := *ignorePtr

	// 2. Process Ignore List
	ignoredExts := make(map[string]bool)
	if ignoreList != "" {
		parts := strings.Split(ignoreList, ",")
		for _, p := range parts {
			cleanExt := strings.TrimSpace(p)
			if !strings.HasPrefix(cleanExt, ".") {
				cleanExt = "." + cleanExt
			}
			ignoredExts[cleanExt] = true
		}
	}

	root, err := os.Getwd()
	if err != nil {
		fmt.Printf("Error getting current directory: %v\n", err)
		os.Exit(1)
	}

	outFile, err := os.Create(outputFilename)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	fmt.Printf("Scanning: %s\nOutput: %s\nIgnoring: %v\n", root, outputFilename, ignoredExts)

	// Call the logic function
	if err := walkAndWrite(root, outFile, outputFilename, ignoredExts); err != nil {
		fmt.Printf("Error: %v\n", err)
	} else {
		fmt.Println("Done!")
	}
}

// walkAndWrite is the core logic, extracted so we can test it
func walkAndWrite(root string, w io.Writer, skipFilename string, ignoredExts map[string]bool) error {
	return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			if strings.HasPrefix(info.Name(), ".") && info.Name() != "." {
				return filepath.SkipDir
			}
			return nil
		}

		if info.Name() == skipFilename {
			return nil
		}

		ext := filepath.Ext(path)
		if ignoredExts[ext] {
			return nil
		}

		isBin, err := isBinary(path)
		if err != nil {
			return nil
		}
		if isBin {
			return nil
		}

		header := fmt.Sprintf("\n========================================\nPATH: %s\n---\n", path)
		if _, err := w.Write([]byte(header)); err != nil {
			return err
		}

		srcFile, err := os.Open(path)
		if err != nil {
			return nil
		}
		defer srcFile.Close()

		if _, err := io.Copy(w, srcFile); err != nil {
			return err
		}

		w.Write([]byte("\n"))
		return nil
	})
}

func isBinary(path string) (bool, error) {
	f, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer f.Close()

	buffer := make([]byte, 512)
	n, err := f.Read(buffer)
	if err != nil && err != io.EOF {
		return false, err
	}
	if n == 0 {
		return false, nil
	}

	if bytes.Contains(buffer[:n], []byte{0}) {
		return true, nil
	}

	contentType := http.DetectContentType(buffer[:n])
	if strings.Contains(contentType, "octet-stream") {
		return true, nil
	}

	return false, nil
}

========================================
PATH: /Users/sarthak/Projects/filepecker/main_test.go
---
package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestIsBinary verifies that our binary detection logic works
func TestIsBinary(t *testing.T) {
	// 1. Create a dummy text file
	tmpText, _ := os.CreateTemp("", "test_*.txt")
	defer os.Remove(tmpText.Name())
	tmpText.WriteString("Hello world")
	tmpText.Close()

	// 2. Create a dummy binary file (contains null byte)
	tmpBin, _ := os.CreateTemp("", "test_*.bin")
	defer os.Remove(tmpBin.Name())
	tmpBin.Write([]byte{0x00, 0x01, 0x02}) // Write raw binary
	tmpBin.Close()

	// Assertions
	isBin, _ := isBinary(tmpText.Name())
	if isBin {
		t.Errorf("Expected text file to be detected as text, got binary")
	}

	isBin, _ = isBinary(tmpBin.Name())
	if !isBin {
		t.Errorf("Expected binary file with null bytes to be detected as binary, got text")
	}
}

// TestWalkAndWrite verifies the full integration
func TestWalkAndWrite(t *testing.T) {
	// 1. Setup a Temporary Directory for testing
	tempDir, err := os.MkdirTemp("", "filepecker_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir) // Clean up after test

	// 2. Create sample files inside tempDir
	
	// A valid Go file (Should be included)
	os.WriteFile(filepath.Join(tempDir, "main.go"), []byte("package main"), 0644)
	
	// A valid Text file (Should be included)
	os.WriteFile(filepath.Join(tempDir, "read.txt"), []byte("some text"), 0644)

	// An Ignored JSON file (Should be ignored by flag)
	os.WriteFile(filepath.Join(tempDir, "data.json"), []byte("{}"), 0644)

	// A Binary file (Should be ignored by detection)
	os.WriteFile(filepath.Join(tempDir, "image.png"), []byte{0x00, 0x00, 0x00}, 0644)

	// A .git directory (Should be ignored by logic)
	os.Mkdir(filepath.Join(tempDir, ".git"), 0755)
	os.WriteFile(filepath.Join(tempDir, ".git", "config"), []byte("secret"), 0644)

	// 3. Run the Logic
	var outputBuffer bytes.Buffer // We write to memory instead of a real file
	ignored := map[string]bool{".json": true}
	
	err = walkAndWrite(tempDir, &outputBuffer, "output.txt", ignored)
	if err != nil {
		t.Fatalf("walkAndWrite returned error: %v", err)
	}

	// 4. Verify Output
	result := outputBuffer.String()

	// Check positives
	if !strings.Contains(result, "package main") {
		t.Error("Output should contain content of main.go")
	}
	if !strings.Contains(result, "some text") {
		t.Error("Output should contain content of read.txt")
	}

	// Check negatives
	if strings.Contains(result, "{}") {
		t.Error("Output should NOT contain content of ignored .json file")
	}
	if strings.Contains(result, "secret") {
		t.Error("Output should NOT contain content of .git folder")
	}
}
